name: check-mega

on:
  pull_request:
    branches: [ "main" ]
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  check-mega:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    env:
      MEGA_BRANCH: mega
      BASE_REF: ${{ github.event.pull_request.base.ref }}   # main
      HEAD_SHA: ${{ github.event.pull_request.head.sha }}   # feature/*
      REPO: ${{ github.repository }}
      API_URL: ${{ github.api_url }}
      TOKEN: ${{ github.token }}

    steps:
      # Guard: sempre roda o job, mas decide se as próximas etapas devem rodar
      - name: Guard (run only for feature/* PRs)
        id: guard
        run: |
          set -euo pipefail
          ref="${{ github.head_ref }}"
          if [[ "$ref" =~ ^feature/ ]]; then
            echo "run=true" >> "$GITHUB_OUTPUT"
            echo "PR de feature: $ref"
          else
            echo "run=false" >> "$GITHUB_OUTPUT"
            echo "PR não é feature/* (head_ref=$ref). Check passará sem validações."
          fi

      - name: Checkout PR head (full history)
        if: steps.guard.outputs.run == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ env.HEAD_SHA }}
          fetch-depth: 0
          persist-credentials: false

      - name: Fetch base (main) and mega
        if: steps.guard.outputs.run == 'true'
        run: |
          set -euo pipefail
          git fetch --no-tags origin "${BASE_REF}":"refs/remotes/origin/${BASE_REF}"
          git fetch --no-tags origin "${MEGA_BRANCH}":"refs/remotes/origin/${MEGA_BRANCH}"

      # (Opcional recomendado) Falha se o repo permitir squash/rebase merge
      - name: Enforce repository merge settings (no squash/rebase)
        if: steps.guard.outputs.run == 'true'
        run: |
          set -euo pipefail
          json=$(curl -sS -H "Authorization: Bearer $TOKEN" -H "Accept: application/vnd.github+json" "$API_URL/repos/$REPO")
          allow_squash=$(echo "$json" | jq -r '.allow_squash_merge')
          allow_rebase=$(echo "$json" | jq -r '.allow_rebase_merge')
          if [ "$allow_squash" = "true" ] || [ "$allow_rebase" = "true" ]; then
            echo "::error title=Repository allows squash/rebase merges::Desabilite squash e rebase merges nas configurações do repositório."
            exit 1
          fi

      - name: List commits in this PR (non-merge)
        if: steps.guard.outputs.run == 'true'
        id: list
        run: |
          set -euo pipefail
          COMMITS=$(git rev-list --no-merges --reverse "origin/${BASE_REF}..${HEAD_SHA}" || true)
          if [ -z "$COMMITS" ]; then
            echo "Sem commits não-merge entre base e head."
            echo "commits=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          printf '%s\n' $COMMITS | tee /tmp/pr_commits.txt
          {
            echo "commits<<EOF"
            printf '%s\n' $COMMITS
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Validate each PR commit exists in mega
        if: steps.guard.outputs.run == 'true' && steps.list.outputs.commits != ''
        run: |
          set -euo pipefail
          missing=0
          while read -r sha; do
            if git merge-base --is-ancestor "$sha" "origin/${MEGA_BRANCH}"; then
              echo "✅ $sha está presente em origin/${MEGA_BRANCH} ($(git log -1 --pretty=%s "$sha"))"
            else
              echo "::error title=Commit ausente na ${MEGA_BRANCH}::${sha} ($(git log -1 --pretty=%s "$sha")) NÃO está em origin/${MEGA_BRANCH}"
              missing=1
            fi
          done < /tmp/pr_commits.txt
          test $missing -eq 0

      - name: Pass-through for non-feature PRs
        if: steps.guard.outputs.run != 'true'
        run: echo "Check liberado: PR não é feature/*."
