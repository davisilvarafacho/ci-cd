name: Validate feature→main commits are in mega

on:
  pull_request:
    branches: [ "main" ]
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  check-commits-present-in-mega:
    name: Ensure PR commits are already in mega
    # Só aplica para PRs cujo branch de origem começa com feature/
    if: startsWith(github.head_ref, 'feature/')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    env:
      MEGA_BRANCH: mega
      BASE_REF: ${{ github.event.pull_request.base.ref }}   # main
      HEAD_SHA: ${{ github.event.pull_request.head.sha }}   # feature/*
      REPO: ${{ github.repository }}
      API_URL: ${{ github.api_url }}
      TOKEN: ${{ github.token }}

    steps:
      - name: Checkout PR head (full history)
        uses: actions/checkout@v4
        with:
          ref: ${{ env.HEAD_SHA }}
          fetch-depth: 0
          persist-credentials: false

      - name: Fetch base (main) and mega
        run: |
          set -euo pipefail
          git fetch --no-tags origin "${BASE_REF}":"refs/remotes/origin/${BASE_REF}"
          git fetch --no-tags origin "${MEGA_BRANCH}":"refs/remotes/origin/${MEGA_BRANCH}"

      # (Opcional porém recomendado) Garante que o repo não permita squash/rebase merges
      - name: Enforce repository merge settings (no squash/rebase)
        run: |
          set -euo pipefail
          json=$(curl -sS -H "Authorization: Bearer $TOKEN" -H "Accept: application/vnd.github+json" "$API_URL/repos/$REPO")
          allow_squash=$(echo "$json" | jq -r '.allow_squash_merge')
          allow_rebase=$(echo "$json" | jq -r '.allow_rebase_merge')
          if [ "$allow_squash" = "true" ] || [ "$allow_rebase" = "true" ]; then
            echo "::error title=Repository allows squash/rebase merges::Desabilite squash e rebase merges nas configurações do repositório para reforçar a política de 'merge commit only'."
            exit 1
          fi

      - name: List commits in this PR (non-merge)
        id: list
        run: |
          set -euo pipefail
          echo "Base: origin/${BASE_REF}"
          echo "Head: ${HEAD_SHA}"
          # Lista os commits (não-merge) que entrariam na main via este PR
          COMMITS=$(git rev-list --no-merges --reverse "origin/${BASE_REF}..${HEAD_SHA}" || true)
          if [ -z "$COMMITS" ]; then
            echo "No commits found between base and head (nothing to check)."
            echo "commits=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          printf '%s\n' $COMMITS | tee /tmp/pr_commits.txt
          {
            echo "commits<<EOF"
            printf '%s\n' $COMMITS
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Validate each PR commit exists in mega
        if: steps.list.outputs.commits != ''
        run: |
          set -euo pipefail
          missing=0
          while read -r sha; do
            if git merge-base --is-ancestor "$sha" "origin/${MEGA_BRANCH}"; then
              echo "✅ $sha está presente em origin/${MEGA_BRANCH} ($(git log -1 --pretty=%s "$sha"))"
            else
              echo "::error title=Commit ausente na ${MEGA_BRANCH}::${sha} ($(git log -1 --pretty=%s "$sha")) NÃO está em origin/${MEGA_BRANCH}"
              missing=1
            fi
          done < /tmp/pr_commits.txt
          if [ "$missing" -ne 0 ]; then
            echo "Um ou mais commits do PR não estão em origin/${MEGA_BRANCH}."
            echo "Ajuste o fluxo: faça merge da feature em ${MEGA_BRANCH} usando *merge commit* (sem squash/rebase), aguarde QA, e só então abra o PR para main."
            exit 1
          fi

      - name: Summary
        if: steps.list.outputs.commits == '' || success()
        run: |
          echo "Todos os commits deste PR já estão presentes em origin/${MEGA_BRANCH}. ✔️"
